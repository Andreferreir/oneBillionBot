//+------------------------------------------------------------------+
//|                                                   oneBillion.mq5 |
//|                                  Copyright 2025, MetaQuotes Ltd. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2025, Mr. CapFree"
#property link      "https://www.mrCapFree.com"
#property version   "1.01"

#include <Trade\Trade.mqh>
CTrade              trade;
CPositionInfo       posinfo;
COrderInfo          ordinfo;
CHistoryOrderInfo   hisinfo;
CDealInfo           dealinfo;

enum enumLotType { Fixed_Lots=0, Pct_of_Balance=1, Pct_of_Equity=2, Pct_of_Free_Margin=3 };

input group "GENERAL SETTINGS"; // General Settings
input int    InpMagic = 12345; // Magic Number
input int    Slippage = 1;

input group "TIME SETTINGS";
input int    StartHour = 16; // START TRADING HOUR
input int    EndHour = 17; // END TRADING HOUR
input int    Secs = 60; // ORDER MODIFICATIONS (Should be same as TF)

input group "MONEY MANAGEMENT"; // MONEY MANAGEMENT
input enumLotType LotType = 0; // Type of Lotsize calculation
input double FixedLot = 0.01; // Fixed Lots 0.0 = MM
input double RiskPercent = 0.5; // Risk MM%

input group "TRADE SETTING IN POINTS"; // TRADE SETTINGS
input double Delta = 0.5; // ORDER DISTANCE
input double MaxDistance = 7; // THETA (Max order distance)
input double Stop = 10; // Stop Loss size
input double MaxTrailing = 4; // COS (Start of Trailing Stop)
input int    MaxSpread = 5555; // Max Spread Limit

double LotStepSize = 0;
double MaxLotSize = 0;
double MinLotSize = 0;
double MarginPerMinLot = 0;
double MinStopDistance = 0;

double CommissionPerPip = 0;
int    SpreadMultiplier = 0;
double AdjustedOrderDistance = 0;
double MinOrderModification = 0;
double TrailingStopActive = 0;

double DeltaX = Delta;

double MinOrderDistance = 0.5;
double MaxTrailingLimit = 7.5;
double OrderModificationFactor = 3;
int    TickCounter = 0;
double PriceToPipRatio = 0;

double BaseTrailingStop = 0;
double TrailingStopBuffer = 0;
double TrailingStopIncrement = 0;
double TrailingStopThreshold = 0;
long   AccountLeverageValue = 0;

double BrokerStopLevel = 0;
double MinFreezeDistance = 0;
int BrokerFreezeLevel = 0;
double CurrentSpread = 0;
double AverageSpread = 0;

int EAModeFlag = 0;
int SpreadArraySize = 0;
int DefaultSpreadPeriod = 30;
double MaxAllowedSpread = 0;
double CalculatedLotSize = 0;

double TrailingStopMax = 0;
double MaxOrderPlacementDistance = 0;
double OrderPlacementStep = 0;
double CalculatedStopLoss = 0;
bool   AllowBuyOrders = false;

bool   AllowSellOrders = false;
bool   SpreadAcceptable = false;
int    LastOrderTimeDiff = 0;
int    LastOrderTime = 0;
int    MinOrderInterval = 0;

double CurrentBuySL = 0;
string OrderCommentText = "MR CapFree";
int    LastBuyOrderTime = 0;
bool   TradeAllowed = false;
double CurrentSellSL = 0;

int    LastSellOrderTime = 0;
int    OrderCheckFrequency = 2;
int    SpreadCalculationMethod = 1;
bool   EnableTrading = false;
double SpreadHistoryArray[];

double BuyOrdersLotSum = 0;
double SellOrdersLotSum = 0;
double BuyOrdersPriceSum = 0;
double SellOrdersPriceSum = 0;
double AverageBuyPrice = 0;
double AverageSellPrice = 0;
double LowestBuyPrice = 99999;
double HighestSellPrice = 0;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   trade.SetExpertMagicNumber(InpMagic);
   
   ChartSetInteger(0, CHART_SHOW_GRID, false);
   
   if (MinOrderDistance > Delta) {
      DeltaX = (MinOrderDistance + 0.1);
   }
   
   if (MaxTrailing > MaxTrailingLimit) {
      MaxTrailingLimit = (MaxTrailing + 0.1);
   }
   
   if (OrderModificationFactor < 1) {
      OrderModificationFactor = 1;
   }
   
   TickCounter = 0;
   PriceToPipRatio = 0;
   BaseTrailingStop = TrailingStopBuffer;

   TrailingStopIncrement = TrailingStopThreshold;
   AccountLeverageValue = AccountInfoInteger(ACCOUNT_LEVERAGE);
   
   LotStepSize = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   MaxLotSize = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   MinLotSize = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   MarginPerMinLot = SymbolInfoDouble(_Symbol, SYMBOL_MARGIN_INITIAL) * MinLotSize;
   
   MinStopDistance = 0;
   BrokerStopLevel = (int)SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
   if (BrokerStopLevel > 0) MinStopDistance = (BrokerStopLevel + 1) * _Point;
   
   MinFreezeDistance = 0;
   BrokerFreezeLevel = (int)SymbolInfoInteger(_Symbol, SYMBOL_TRADE_FREEZE_LEVEL);
   if (BrokerFreezeLevel > 0) MinFreezeDistance = (BrokerFreezeLevel + 1) * _Point;
   
   if (BrokerFreezeLevel > 0 || BrokerFreezeLevel < 0)
   {
      Comment("WARNING! Broker is not suitable, the stoplevel is greater than zero.");
   }
   
   double Ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double Bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   AverageSpread = NormalizeDouble(Ask - Bid, _Digits);
   
   SpreadArraySize = (EAModeFlag == 0) ? DefaultSpreadPeriod : 3; // if EAModeFlag == 0, then DefaultSpreadPeriod else 3
   
   ArrayResize(SpreadHistoryArray, SpreadArraySize);

   // Initialize spread history array to avoid zeros on first ticks
   for(int i=0; i<SpreadArraySize; i++)
      SpreadHistoryArray[i] = AverageSpread;
   
   MaxAllowedSpread = NormalizeDouble((MaxSpread * _Point), _Digits);
   
   // Note: TesterHideIndicators is not a standard MQL5 function; assuming it's a custom or removed for now
   // TesterHideIndicators(true);

   return(INIT_SUCCEEDED);
}
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   //---
   
}
//+------------------------------------------------------------------+
//| Helper: open pending order with MqlTradeRequest/OrderSend        |
//+------------------------------------------------------------------+
bool OpenPendingOrder(ENUM_ORDER_TYPE type, string symbol, double volume, double price, double sl, double tp, string comment, ulong &out_ticket)
{
   MqlTradeRequest request;
   MqlTradeResult  result;
   ZeroMemory(request);
   ZeroMemory(result);

   request.action   = TRADE_ACTION_PENDING;           // abrir ordem pendente
   request.symbol   = symbol;
   request.volume   = volume;
   request.type     = type;                           // ORDER_TYPE_BUY_STOP ou SELL_STOP
   request.price    = price;
   request.sl       = sl;
   request.tp       = tp;
   request.deviation= Slippage;                       // input Slippage
   request.magic    = InpMagic;
   request.comment  = comment;
   request.type_filling = ORDER_FILLING_RETURN;      // mais permissivo no tester
   request.type_time    = ORDER_TIME_GTC;

   if(!OrderSend(request, result))
   {
      int err = GetLastError();
      PrintFormat("OrderSend() failed to submit request. errno=%d", err);
      return false;
   }

   PrintFormat("OrderSend() result: retcode=%d request_price=%.8f result_order=%I64u comment=%s",
               result.retcode, price, result.order, result.comment);

   // Consider common successful retcodes (PLACED / DONE)
   if(result.retcode == TRADE_RETCODE_DONE || result.retcode == TRADE_RETCODE_PLACED || result.retcode == TRADE_RETCODE_DONE_PARTIAL)
   {  
      out_ticket = (ulong)result.order;
      return true;
   }
   else
   {
      PrintFormat("OrderSend failed. retcode=%d result.comment=%s", result.retcode, result.comment);
      return false;
   }
}
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   int CurrentTime = (int)TimeCurrent();
   int PendingBuyCount = 0;
   int PendingSellCount = 0;
   int OpenBuyCount = 0;
   int OpenSellCount = 0;
   int TotalBuyCount = 0;
   int TotalSellCount = 0;
   double OrderLotsValue = 0;
   double OrderStopLossValue = 0;
   double OrderTakeProfitValue = 0;
   double OrderOpenPriceValue = 0;
   double NewOrderTakeProfit = 0;
   BuyOrdersLotSum = 0;
   SellOrdersPriceSum = 0;
   SellOrdersLotSum = 0;
   AverageBuyPrice = 0;
   AverageSellPrice = 0;
   LowestBuyPrice = 99999;
   HighestSellPrice = 0;

   TickCounter++;
   
   if (PriceToPipRatio == 0){
      HistorySelect(0, TimeCurrent());
      for (int j = HistoryDealsTotal() - 1; j >= 0; j--)
      {
         ulong ticket = HistoryDealGetTicket(j);
         if(ticket == 0) continue;
   
         if(HistoryDealGetString(ticket, DEAL_SYMBOL) != _Symbol) continue;
         if(HistoryDealGetDouble(ticket, DEAL_PROFIT) <= 0) continue;
         if(HistoryDealGetInteger(ticket, DEAL_ENTRY) != DEAL_ENTRY_OUT) continue;
   
         ulong posID = HistoryDealGetInteger(ticket, DEAL_POSITION_ID);
         if(posID == 0) continue;
   
         // Find the corresponding entry deal
         for(int i = j - 1; i >= 0; i--)
         {
            ulong entryTicket = HistoryDealGetTicket(i);
            if(entryTicket == 0) continue;
            if(!HistoryDealSelect(entryTicket)) continue;
            if(posID != HistoryDealGetInteger(entryTicket, DEAL_POSITION_ID)) continue;
   
            double entryPrice = HistoryDealGetDouble(entryTicket, DEAL_PRICE);
            double exitPrice = HistoryDealGetDouble(ticket, DEAL_PRICE);
            double profit = HistoryDealGetDouble(ticket, DEAL_PROFIT);
            double commission = HistoryDealGetDouble(ticket, DEAL_COMMISSION);
   
            if(exitPrice != entryPrice)
            {
               PriceToPipRatio = fabs(profit) / fabs(exitPrice - entryPrice);
               CommissionPerPip = -commission / (fabs(exitPrice - entryPrice) / _Point);
               break;
            }
         }
         if (PriceToPipRatio > 0) break;
      }
   }
   
   double Ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double Bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);

   // DEBUG: main values
   PrintFormat("DEBUG: Ask=%.8f Bid=%.8f AvgSpread=%.8f MaxAllowed=%.8f FreeMargin=%.2f Leverage=%d",
               Ask, Bid, AverageSpread, MaxAllowedSpread, AccountInfoDouble(ACCOUNT_MARGIN_FREE), (int)AccountInfoInteger(ACCOUNT_LEVERAGE));
   
   // Update spread history array
   double newSpread = NormalizeDouble(Ask - Bid, _Digits);
   ArrayCopy(SpreadHistoryArray, SpreadHistoryArray, 0, 1, SpreadArraySize - 1);
   SpreadHistoryArray[SpreadArraySize - 1] = newSpread;
   
   // Calculate MA of spread
   double sum = 0.0;
   for(int i = 0; i < SpreadArraySize; i++) {
      sum += SpreadHistoryArray[i];
   }
   CurrentSpread = sum / SpreadArraySize;
   
   // Calculate average spread including commission
   AverageSpread = MathMax(SpreadMultiplier * _Point, CurrentSpread + CommissionPerPip);
   
   // Calculate order distances
   AdjustedOrderDistance = MathMax(AverageSpread * Delta, MinStopDistance);
   MinOrderModification = MathMax(AverageSpread * MinOrderDistance, MinFreezeDistance);
   
   // Calculate trailing stop values
   TrailingStopActive = AverageSpread * MaxTrailing;
   TrailingStopMax = AverageSpread * MaxTrailingLimit;
   MaxOrderPlacementDistance = AverageSpread * MaxDistance;
   OrderPlacementStep = MinOrderModification / OrderModificationFactor;
   CalculatedStopLoss = MathMax(AverageSpread * Stop, MinStopDistance);

   BuyOrdersLotSum = 0;
   SellOrdersLotSum = 0;
   BuyOrdersPriceSum = 0;
   SellOrdersPriceSum = 0;
   CurrentBuySL = 0;
   CurrentSellSL = 0;

   for (int i = PositionsTotal() - 1; i >= 0; i--)
   {
      if (posinfo.SelectByIndex(i) && 
          posinfo.Symbol() == _Symbol &&
          posinfo.Magic() == InpMagic)
      {
         double price = posinfo.PriceOpen();
         double sl = posinfo.StopLoss();
         double lots = posinfo.Volume();
   
         if (posinfo.PositionType() == POSITION_TYPE_BUY)
         {
            OpenBuyCount++;
            if (sl > 0 && (sl < price))
            {
               TotalBuyCount++;
               CurrentBuySL += sl;
            }
            BuyOrdersPriceSum += price * lots;
            BuyOrdersLotSum += lots;
            if (price < LowestBuyPrice) LowestBuyPrice = price;
         }
         else if (posinfo.PositionType() == POSITION_TYPE_SELL)
         {
            OpenSellCount++;
            if (sl > 0 && (sl > price)) 
            {
               TotalSellCount++;
               CurrentSellSL += sl;
            }
            SellOrdersPriceSum += price * lots;
            SellOrdersLotSum += lots;
            if (price > HighestSellPrice) HighestSellPrice = price;
         }
      }
   }
   
   for(int i = OrdersTotal() - 1; i >= 0; i--)
   {
      if(ordinfo.SelectByIndex(i) &&
         ordinfo.Symbol() == _Symbol &&
         ordinfo.Magic() == InpMagic)
      {
         if(ordinfo.OrderType() == ORDER_TYPE_BUY_STOP)
         {
            PendingBuyCount++;
            TotalBuyCount++;
         }
         else if(ordinfo.OrderType() == ORDER_TYPE_SELL_STOP)
         {
            PendingSellCount++;
            TotalSellCount++;
         }
      }
   }

   if (BuyOrdersLotSum > 0)
      AverageBuyPrice = NormalizeDouble((BuyOrdersPriceSum / BuyOrdersLotSum), _Digits);
   if (SellOrdersLotSum > 0)
      AverageSellPrice = NormalizeDouble((SellOrdersPriceSum / SellOrdersLotSum), _Digits);
   
   MqlDateTime BrokerTime;
   TimeToStruct(TimeCurrent(), BrokerTime);
   
   // Process pending orders
   for(int i = OrdersTotal()-1; i >= 0; i--) {
      if(!ordinfo.SelectByIndex(i)) continue;
      if(_Symbol != ordinfo.Symbol() || ordinfo.Magic() != InpMagic) continue;
   
      ulong ticket = ordinfo.Ticket();
      ENUM_ORDER_TYPE type = ordinfo.OrderType();
      double openPrice = ordinfo.PriceOpen();
      double sl = ordinfo.StopLoss();
      double tp = ordinfo.TakeProfit();
      double lots = ordinfo.VolumeCurrent();
      
      // Process buy stop orders
      if(type == ORDER_TYPE_BUY_STOP)
      {
         bool allowTrade = (BrokerTime.hour >= StartHour && BrokerTime.hour <= EndHour);
         if(AverageSpread > MaxAllowedSpread || !allowTrade)
         {
            trade.OrderDelete(ticket);
            continue;
         }
      
         int timeDiff = (int)(CurrentTime - LastBuyOrderTime);
      
         bool needsModification = (timeDiff >= Secs) ||
                                  ((TickCounter % OrderCheckFrequency == 0) &&
                                  ((OpenBuyCount < 1 && (openPrice - Ask) < MinOrderModification) ||
                                   (openPrice - Ask) < OrderPlacementStep ||
                                   (openPrice - Ask) > OrderPlacementStep));
                                   
         if (needsModification == true)
         {
            double distance = AdjustedOrderDistance;
            if(OpenBuyCount > 0) distance /= OrderModificationFactor;
            distance = MathMax(distance, MinStopDistance);
         
            double modifiedPrice = NormalizeDouble(Ask + distance, _Digits);
         
            double modifiedSl = (OpenBuyCount > 0)
                ? CurrentBuySL
                : NormalizeDouble(modifiedPrice - CalculatedStopLoss, _Digits);
         
            if ((OpenBuyCount == 0 || modifiedPrice > AverageBuyPrice) && modifiedPrice != openPrice &&
                (openPrice - Ask) > MinFreezeDistance)
            {
                trade.OrderModify(ticket, modifiedPrice, modifiedSl, tp, ORDER_TIME_GTC, 0);
                LastBuyOrderTime = CurrentTime;
            }
         }
      }
   }
   
   // Process positions for trailing stops
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      if(!posinfo.SelectByIndex(i)) continue;
      if(posinfo.Symbol() != _Symbol || posinfo.Magic() != InpMagic) continue;
   
      ulong ticket = posinfo.Ticket();
      ENUM_POSITION_TYPE type = posinfo.PositionType();
      double openPrice = posinfo.PriceOpen();
      double sl = posinfo.StopLoss();
      double tp = posinfo.TakeProfit();
   
      // Process buy positions
      if(type == POSITION_TYPE_BUY)
      {
         double priceMove = MathMax(Bid - openPrice + CommissionPerPip, 0);
         double trailDist = CalculateTrailingStop(priceMove, MinStopDistance, TrailingStopActive, BaseTrailingStop, TrailingStopMax);
           
         double modifiedSl = NormalizeDouble(Bid - trailDist, _Digits);
         double triggerLevel = openPrice + CommissionPerPip + TrailingStopIncrement; 
            
         if(Bid > triggerLevel &&
            (sl == 0.0 || Bid - sl > trailDist) && modifiedSl != sl)
         {
            trade.PositionModify(ticket, modifiedSl, tp);
         }
      }
      // Process sell positions
      else if(type == POSITION_TYPE_SELL)
      {
         double priceMove = MathMax(openPrice - Ask - CommissionPerPip, 0);
         double trailDist = CalculateTrailingStop(priceMove, MinStopDistance, TrailingStopActive, BaseTrailingStop, TrailingStopMax);
   
         double modifiedSl = NormalizeDouble(Ask + trailDist, _Digits);
         double triggerLevel = openPrice - CommissionPerPip - TrailingStopIncrement;
       
         if(Ask < triggerLevel && 
            (sl == 0 || sl - Ask > trailDist) && modifiedSl != sl)
         {
            trade.PositionModify(ticket, modifiedSl, tp);
         }
      }
   }

   // Place new buy stop order if conditions met
   if ((OrderModificationFactor > 1 && TotalBuyCount > 1) || OpenBuyCount < 1)
   {
      if (PendingBuyCount < 1)
      {
         bool spreadOK = (AverageSpread <= MaxAllowedSpread);
         bool timeOK   = (BrokerTime.hour >= StartHour && BrokerTime.hour <= EndHour);
   
         if (spreadOK && timeOK && (CurrentTime - LastOrderTime) > MinOrderInterval && EAModeFlag == 0)
         {
            // Lot size calculation
            if (LotType == Fixed_Lots)
            {
               CalculatedLotSize = MathRound(FixedLot / LotStepSize) * LotStepSize;
               CalculatedLotSize = MathMax(CalculatedLotSize, MinLotSize); // Enforce minimum
            }
            else
            {
               CalculatedLotSize = calcLots(CalculatedStopLoss);
            }
            double marginRequired = 0.0;
            double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
               
            bool okMargin = OrderCalcMargin(ORDER_TYPE_BUY_STOP, _Symbol, CalculatedLotSize, ask, marginRequired);
            PrintFormat("OrderCalcMargin returned %s  marginReq=%.2f freeMargin=%.2f", okMargin ? "true":"false", marginRequired, AccountInfoDouble(ACCOUNT_MARGIN_FREE));

            if(okMargin && AccountInfoDouble(ACCOUNT_MARGIN_FREE) > marginRequired){
         
               double stop_level = (double)SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL) * _Point;
               double orderDist  = MathMax(MathMax(AdjustedOrderDistance, MinFreezeDistance), MinStopDistance);
               orderDist = MathMax(orderDist, stop_level + _Point); // force minimum respecting broker stop level
               double orderPrice = NormalizeDouble(ask + orderDist, _Digits);
               double orderSL    = (OpenBuyCount > 0 
                                   ? CurrentBuySL
                                   : NormalizeDouble(orderPrice - CalculatedStopLoss, _Digits));
                  
               ulong placedTicket = 0;
               if(OpenPendingOrder(ORDER_TYPE_BUY_STOP, _Symbol, CalculatedLotSize, orderPrice, orderSL, NewOrderTakeProfit, OrderCommentText, placedTicket))
               {
                  LastBuyOrderTime = (int)TimeCurrent();
                  LastOrderTime    = (int)TimeCurrent();
                  PrintFormat("BUY_STOP placed ticket=%I64u price=%.8f lots=%.2f SL=%.8f", placedTicket, orderPrice, CalculatedLotSize, orderSL);
               }
               else
               {
                  PrintFormat("BUY_STOP failed price=%.8f lots=%.2f SL=%.8f", orderPrice, CalculatedLotSize, orderSL);
               }
            }
            else
            {
               Print("Not enough margin or OrderCalcMargin failed for BUY_STOP");
            }
         }
      }
   }
   
   // Place new sell stop order if conditions met
   if ((OrderModificationFactor > 1 && TotalSellCount > 1) || OpenSellCount < 1)
   {
      if (PendingSellCount < 1)
      {
         bool spreadOK = (AverageSpread <= MaxAllowedSpread);
         bool timeOK   = (BrokerTime.hour >= StartHour && BrokerTime.hour <= EndHour);
   
         if (spreadOK && timeOK && (CurrentTime - LastOrderTime) > MinOrderInterval && EAModeFlag == 0)
         {
            // Lot size calculation
            if (LotType == Fixed_Lots)
            {
               CalculatedLotSize = MathRound(FixedLot / LotStepSize) * LotStepSize;
               CalculatedLotSize = MathMax(CalculatedLotSize, MinLotSize); // Enforce minimum
            }
            else
            {
               CalculatedLotSize = calcLots(CalculatedStopLoss);
            }
            double marginRequired = 0.0;
            double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
               
            bool okMargin = OrderCalcMargin(ORDER_TYPE_SELL_STOP, _Symbol, CalculatedLotSize, bid, marginRequired);
            PrintFormat("OrderCalcMargin returned %s  marginReq=%.2f freeMargin=%.2f", okMargin ? "true":"false", marginRequired, AccountInfoDouble(ACCOUNT_MARGIN_FREE));

            if (okMargin && AccountInfoDouble(ACCOUNT_MARGIN_FREE) > marginRequired)
            {
               double stop_level = (double)SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL) * _Point;
               double orderDist  = MathMax(MathMax(AdjustedOrderDistance, MinFreezeDistance), MinStopDistance);
               orderDist = MathMax(orderDist, stop_level + _Point); // force minimum respecting broker stop level
               double orderPrice = NormalizeDouble(bid - orderDist, _Digits);
               double orderSL    = (OpenSellCount > 0) 
                                   ? CurrentSellSL 
                                   : NormalizeDouble(orderPrice + CalculatedStopLoss, _Digits);
               ulong placedTicket = 0;
               if(OpenPendingOrder(ORDER_TYPE_SELL_STOP, _Symbol, CalculatedLotSize, orderPrice, orderSL, NewOrderTakeProfit, OrderCommentText, placedTicket))
               {
                  LastSellOrderTime = (int)TimeCurrent();
                  LastOrderTime     = (int)TimeCurrent();
                  PrintFormat("SELL_STOP placed ticket=%I64u price=%.8f lots=%.2f SL=%.8f", placedTicket, orderPrice, CalculatedLotSize, orderSL);
               }
               else
               {
                  PrintFormat("SELL_STOP failed price=%.8f lots=%.2f SL=%.8f", orderPrice, CalculatedLotSize, orderSL);
               }
            }
            else
            {
               Print("Not enough margin or OrderCalcMargin failed for SELL_STOP");
            }
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Calculate Trailing Stop                                          |
//+------------------------------------------------------------------+
double CalculateTrailingStop(double priceMove, double minDist, double activeDist, double baseDist, double maxDist)
{
   if (maxDist == 0) return MathMax(activeDist, minDist);

   double ratio = priceMove / maxDist;
   double dynamicDist = (activeDist - baseDist) * ratio + baseDist;
   return MathMax(MathMin(dynamicDist, activeDist), minDist);
}

//+------------------------------------------------------------------+
//| Calculate Lot Size                                               |
//+------------------------------------------------------------------+
double calcLots(double slPoints) 
{
   double lots = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   
   double AccountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   double EquityBalance = AccountInfoDouble(ACCOUNT_EQUITY);
   double FreeMargin = AccountInfoDouble(ACCOUNT_MARGIN_FREE);
   
   double risk = 0;

   switch (LotType) {
      case Fixed_Lots: 
         lots = FixedLot; 
         return lots;  
      case Pct_of_Balance: 
         risk = AccountBalance * RiskPercent / 100; 
         break;
      case Pct_of_Equity: 
         risk = EquityBalance * RiskPercent / 100; 
         break;
      case Pct_of_Free_Margin: 
         risk = FreeMargin * RiskPercent / 100; 
         break;
   }

   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   double moneyPerLotStep = (slPoints / tickSize) * tickValue * lotStep;
   lots = MathFloor(risk / moneyPerLotStep) * lotStep;

   double minVolume = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxVolume = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double volumeLimit = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_LIMIT);

   if (volumeLimit != 0) lots = MathMin(lots, volumeLimit);
   if (maxVolume != 0) lots = MathMin(lots, maxVolume);
   lots = MathMax(lots, minVolume);
   lots = NormalizeDouble(lots, 2);

   return lots;
}

